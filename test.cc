#include <chrono>
#include <iostream>
#include <random>
#include <string.h>
//for async IO
#include <thread>
//for ycsb
#include<limits.h>
#include<math.h>
#include <unistd.h>
#include "bplus_tree.h"

//extern off_t global_lsn;
//+++++++++++++++++++++YCSB Generator+++++++++++++++++++++++++++++++++++++++++++++++++
int afterLoad[64]={0};
int aftertest[64]={0};
extern off_t malloc_cnt[30];
extern off_t free_cnt[30];
int testphase[64][50]={0};
extern int kMaxPages;

namespace generator
{

/*
     Generating yscb-style sorted hashkey 
     Usage:generating string for UniformGenerator(I guess)
*/
static inline void shuffle(uint64_t a[], uint64_t n)
{
  uint64_t index, tmp, i;
  srand(315);

  for (int i = n - 1; i > 0; i--)
  {
    index = rand() % i;
    tmp = a[i];
    a[i] = a[index];
    a[index] = tmp;
  }
}
static inline long long YCSBKey_hash(long long val)
{
  long long FNV_offset_basis_64 = 0xCBF29CE484222325LL;
  long long FNV_prime_64 = 1099511628211LL;
  long long hashval = FNV_offset_basis_64;
  for (int i = 0; i < 8; i++)
  {
    long long octet = val & 0x00ff;
    val = val >> 8;
    hashval = hashval ^ octet;
    hashval = hashval * FNV_prime_64;
  }
  return llabs(hashval);
}
class YCSBKeyGenerator
{
private:
  long long *keypool;
  int index;
  int max;

public:
  YCSBKeyGenerator(int startnum, int filenum, int keysize) : index(0)
  {
    keypool = new long long[keysize * filenum];
    for (long long i = 0; i < keysize * filenum; i++)
    {
      keypool[i] = YCSBKey_hash(i + startnum);
    }
    sort(keypool, 0, keysize * filenum);
  }
  ~YCSBKeyGenerator()
  {
    delete keypool;
  }
  void sort(long long *num, int top, int bottom)
  {
    int middle;
    if (top < bottom)
    {
      middle = partition(num, top, bottom);
      sort(num, top, middle);        // sort first section
      sort(num, middle + 1, bottom); // sort second section
    }
    return;
  }
  int partition(long long *array, int top, int bottom)
  {
    long long x = array[top];
    int i = top - 1;
    int j = bottom + 1;
    long long temp;
    do
    {
      do
      {
        j--;
      } while (x > array[j]);

      do
      {
        i++;
      } while (x < array[i]);

      if (i < j)
      {
        temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
    } while (i < j);
    return j; // returns middle subscript
  }

  long long nextKey()
  {
    return keypool[index++];
  }
};

class Utils
{
public:
  /**
       * Hash an integer value.
       */
  static long hash(long val)
  {
    return FNVhash64(val);
  }

  static const int FNV_offset_basis_32 = 0x811c9dc5;
  static const int FNV_prime_32 = 16777619;

  /**
       * 32 bit FNV hash. Produces more "random" hashes than (say) std::string.hashCode().
       *
       * @param val The value to hash.
       * @return The hash value
       */
  static int FNVhash32(int val)
  {
    //from http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash
    int hashval = FNV_offset_basis_32;

    for (int i = 0; i < 4; i++)
    {
      int octet = val & 0x00ff;
      val = val >> 8;

      hashval = hashval ^ octet;
      hashval = hashval * FNV_prime_32;
      //hashval = hashval ^ octet;
    }
    return labs(hashval);
  }

  static const long FNV_offset_basis_64 = 0xCBF29CE484222325L;
  static const long FNV_prime_64 = 1099511628211L;

  /**
       * 64 bit FNV hash. Produces more "random" hashes than (say) std::string.hashCode().
       *
       * @param val The value to hash.
       * @return The hash value
       */
  static long FNVhash64(long val)
  {
    //from http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash
    long hashval = FNV_offset_basis_64;

    for (int i = 0; i < 8; i++)
    {
      long octet = val & 0x00ff;
      val = val >> 8;

      hashval = hashval ^ octet;
      hashval = hashval * FNV_prime_64;
      //hashval = hashval ^ octet;
    }
    return labs(hashval);
  }
};

class Generator
{
  /**
	 * Generate the next string in the distribution.
	 */
public:
  virtual std::string nextString() = 0;

  /**
	 * Return the previous string generated by the distribution; e.g., returned from the last nextString() call.
	 * Calling lastString() should not advance the distribution or have any side effects. If nextString() has not yet
	 * been called, lastString() should return something reasonable.
	 */
  virtual std::string lastString() = 0;
  virtual ~Generator(){};
};

/*
    2.2 IntegerGenerator
        do noothing but define methods of nextint(string) and lastint(string)
    */
class IntegerGenerator : public Generator
{
  int lastint;

  /**
	 * Set the last value generated. IntegerGenerator subclasses must use this call
	 * to properly set the last string value, or the lastString() and lastInt() calls won't work.
	 */
public:
  void setLastInt(int last)
  {
    lastint = last;
  }

  /**
	 * Return the next value as an int. When overriding this method, be sure to call setLastString() properly, or the lastString() call won't work.
	 */
  virtual int nextInt() = 0;

  /**
	 * Generate the next string in the distribution.
	 */
  std::string nextString()
  {
    char buf[100];
    sprintf(buf, "%d", nextInt()); //����buf��
    std::string s = buf;
    return s;
  }
  /**
		 * Return the previous int generated by the distribution. This call is unique to IntegerGenerator subclasses, and assumes
		 * IntegerGenerator subclasses always return ints for nextInt() (e.g. not arbitrary strings).
		 */
  int lastInt()
  {
    return lastint;
  }
  /**
	 * Return the previous string generated by the distribution; e.g., returned from the last nextString() call.
	 * Calling lastString() should not advance the distribution or have any side effects. If nextString() has not yet
	 * been called, lastString() should return something reasonable.
	 */
  std::string lastString()
  {
    char buf[100];
    sprintf(buf, "%d", lastint);
    std::string s = buf;
    return s;
  }

  /**
	 * Return the expected value (mean) of the values this generator will return.
	 */
  virtual double mean() = 0;
  virtual ~IntegerGenerator(){};
};
/*
    2.3 CounterGenerator :used by other generators as a counter
        input:countstart
        output:nextInt() to generate a next int & lastInt() to generate a last int
            
    */
class CounterGenerator : public IntegerGenerator
{
  int counter;
  int max;
  /**
	 * Create a counter that starts at countstart
	 */
public:
  CounterGenerator(int countstart, int countend = INT_MAX) : counter(countstart), max(countend) //countstart��ֵ��counter
  {
    counter = countstart > 0 ? countstart : 0;
    IntegerGenerator::setLastInt(counter - 1);
    max = countend > counter ? countend : INT_MAX;
  }

  /**
	 * If the generator returns numeric (integer) values, return the next value as an int.
	 * Default is to return -1, which
	 * is appropriate for generators that do not return numeric values.
	 */
  int nextInt()
  {
    int ret = (counter++) % max;
    IntegerGenerator::setLastInt(ret);
    //std::cout<<"nextint:"<<ret<<std::endl;
    return ret;
  }
  int lastInt()
  {
    return counter - 1;
  }
  double mean()
  {
    return 0;
    //throw new UnsupportedOperationException("Can't compute mean of non-stationary distribution!");
  }
};

/*
    3.Special generator: will be used as key_generating method 
  */

/*
    3.1 ZipfianGenerator
        input:  can be modified
                default: _items The number of items in the distribution
        output： (1)nextLong() or nextInt()
                    @param itemcount The number of items in the distribution.
		                @return The next item in the sequence.
                
*/
class ZipfianGenerator : public IntegerGenerator
{
public:
  static constexpr double ZIPFIAN_CONSTANT = 0.99;

private:
  /**
	 * Number of items.
	 */
  long items;

  /**
	 * Min item to generate.
	 */
  long base;

  /**
	 * The zipfian constant to use.
	 */
  double zipfianconstant;

  /**
	 * Computed parameters for generating the distribution.
	 */
  double alpha, zetan, eta, theta, zeta2theta;

  /**
	 * The number of items used to compute zetan the last time.
	 */
  long countforzeta;

  /**
	 * Flag to prevent problems. If you increase the number of items the zipfian generator is allowed to choose from, this code will incrementally compute a new zeta
	 * value for the larger itemcount. However, if you decrease the number of items, the code computes zeta from scratch; this is expensive for large itemsets.
	 * Usually this is not intentional; e.g. one thread thinks the number of items is 1001 and calls "nextLong()" with that item count; then another thread who thinks the
	 * number of items is 1000 calls nextLong() with itemcount=1000 triggering the expensive recomputation. (It is expensive for 100 million items, not really for 1000 items.) Why
	 * did the second thread think there were only 1000 items? maybe it read the item count before the first thread incremented it. So this flag allows you to say if you really do
	 * want that recomputation. If true, then the code will recompute zeta if the itemcount goes down. If false, the code will assume itemcount only goes up, and never recompute.
	 */
  bool allowitemcountdecrease;

  /******************************* Constructors **************************************/

  /**
	 * Create a zipfian generator for the specified number of items.
	 * @param _items The number of items in the distribution.
	 */
public:
  ZipfianGenerator(long _items)
  {
    new (this) ZipfianGenerator(0, _items - 1);
  }

  /**
	 * Create a zipfian generator for items between min and max.
	 * @param _min The smallest integer to generate in the sequence.
	 * @param _max The largest integer to generate in the sequence.
	 */
  ZipfianGenerator(long _min, long _max)
  {
    new (this) ZipfianGenerator(_min, _max, ZIPFIAN_CONSTANT);
  }

  /**
	 * Create a zipfian generator for the specified number of items using the specified zipfian constant.
	 *
	 * @param _items The number of items in the distribution.
	 * @param _zipfianconstant The zipfian constant to use.
	 */
  ZipfianGenerator(long _items, double _zipfianconstant)
  {
    new (this) ZipfianGenerator(0, _items - 1, _zipfianconstant);
  }

  /**
	 * Create a zipfian generator for items between min and max (inclusive) for the specified zipfian constant.
	 * @param min The smallest integer to generate in the sequence.
	 * @param max The largest integer to generate in the sequence.
	 * @param _zipfianconstant The zipfian constant to use.
	 */
  ZipfianGenerator(long min, long max, double _zipfianconstant)
  {
    new (this) ZipfianGenerator(min, max, _zipfianconstant, zetastatic(max - min + 1, _zipfianconstant));
  }
  /**
	 * Create a zipfian generator for items between min and max (inclusive) for the specified zipfian constant, using the precomputed value of zeta.
	 *
	 * @param min The smallest integer to generate in the sequence.
	 * @param max The largest integer to generate in the sequence.
	 * @param _zipfianconstant The zipfian constant to use.
	 * @param _zetan The precomputed zeta constant.
	 */
  ZipfianGenerator(long min, long max, double _zipfianconstant, double _zetan)
  {
    //std::cout<<"terry is good"<<std::endl;
    allowitemcountdecrease = false;
    items = max - min + 1;
    base = min;
    zipfianconstant = _zipfianconstant;

    theta = zipfianconstant;

    zeta2theta = zeta(2, theta);

    alpha = 1.0 / (1.0 - theta);
    //zetan=zeta(items,theta);
    zetan = _zetan;
    countforzeta = items;
    eta = (1 - pow(2.0 / items, 1 - theta)) / (1 - zeta2theta / zetan);
    srand(time(NULL));
    nextInt();
    //System.out.println("XXXX 4 XXXX");
  }

  /**************************************************************************/

  /**
	 * Compute the zeta constant needed for the distribution. Do this from scratch for a distribution with n items, using the
	 * zipfian constant theta. Remember the value of n, so if we change the itemcount, we can recompute zeta.
	 *
	 * @param n The number of items to compute zeta over.
	 * @param theta The zipfian constant.
	 */
  double zeta(long n, double theta)
  {
    countforzeta = n;
    return zetastatic(n, theta);
  }

  /**
	 * Compute the zeta constant needed for the distribution. Do this from scratch for a distribution with n items, using the
	 * zipfian constant theta. This is a static version of the function which will not remember n.
	 * @param n The number of items to compute zeta over.
	 * @param theta The zipfian constant.
	 */
  static double zetastatic(long n, double theta)
  {
    return zetastatic(0, n, theta, 0);
  }

  /**
	 * Compute the zeta constant needed for the distribution. Do this incrementally for a distribution that
	 * has n items now but used to have st items. Use the zipfian constant theta. Remember the new value of
	 * n so that if we change the itemcount, we'll know to recompute zeta.
	 *
	 * @param st The number of items used to compute the last initialsum
	 * @param n The number of items to compute zeta over.
	 * @param theta The zipfian constant.
     * @param initialsum The value of zeta we are computing incrementally from.
	 */
  double zeta(long st, long n, double theta, double initialsum)
  {
    countforzeta = n;
    return zetastatic(st, n, theta, initialsum);
  }

  /**
	 * Compute the zeta constant needed for the distribution. Do this incrementally for a distribution that
	 * has n items now but used to have st items. Use the zipfian constant theta. Remember the new value of
	 * n so that if we change the itemcount, we'll know to recompute zeta.
	 * @param st The number of items used to compute the last initialsum
	 * @param n The number of items to compute zeta over.
	 * @param theta The zipfian constant.
     * @param initialsum The value of zeta we are computing incrementally from.
	 */
  static double zetastatic(long st, long n, double theta, double initialsum)
  {
    double sum = initialsum;
    //std::cout<<n<<std::endl;
    // std::cout<<st<<" ";
    //std::cout<<n<<" ";
    //std::cout<<theta<<std::endl;
    for (long i = st; i < n; i++)
    {
      sum += 1 / (pow(i + 1, theta));
    }

    //std::cout<<"sum="<<sum<<std::endl;

    return sum;
  }

  /****************************************************************************************/
  /**
		 * Generate the next item as a long.
		 *
		 * @param itemcount The number of items in the distribution.
		 * @return The next item in the sequence.
		 */
  long nextLong(long itemcount)
  {
    //from "Quickly Generating Billion-Record Synthetic Databases", Jim Gray et al, SIGMOD 1994
    // std::cout<<"got here"<<std::endl;
    if (itemcount != countforzeta)
    {

      //have to recompute zetan and eta, since they depend on itemcount
      if (itemcount > countforzeta)
      {
        //System.err.println("WARNING: Incrementally recomputing Zipfian distribtion. (itemcount="+itemcount+" countforzeta="+countforzeta+")");

        //we have added more items. can compute zetan incrementally, which is cheaper
        zetan = zeta(countforzeta, itemcount, theta, zetan);
        eta = (1 - pow(2.0 / items, 1 - theta)) / (1 - zeta2theta / zetan);
      }
      else if ((itemcount < countforzeta) && (allowitemcountdecrease))
      {
        //have to start over with zetan
        //note : for large itemsets, this is very slow. so don't do it!

        //TODO: can also have a negative incremental computation, e.g. if you decrease the number of items, then just subtract
        //the zeta sequence terms for the items that went away. This would be faster than recomputing from scratch when the number of items
        //decreases

        //std::cout<<"WARNING: Recomputing Zipfian distribtion. This is slow and should be avoided. (itemcount="+itemcount+" countforzeta="+countforzeta+")";

        zetan = zeta(itemcount, theta);
        eta = (1 - pow(2.0 / items, 1 - theta)) / (1 - zeta2theta / zetan);
      }
    }

    double u = (double)(rand() / (double)RAND_MAX);
    //std::cout<<"random u="<<u<<std::endl;
    double uz = u * zetan;

    if (uz < 1.0)
    {
      return 0;
    }

    if (uz < 1.0 + pow(0.5, theta))
    {
      return 1;
    }

    long ret = base + (long)((itemcount)*pow(eta * u - eta + 1, alpha));
    setLastInt((int)ret);
    return ret;
  }
  /**
	 * Generate the next item. this distribution will be skewed����б�� toward lower integers; e.g. 0 will
	 * be the most popular, 1 the next most popular, etc.
	 * @param itemcount The number of items in the distribution.
	 * @return The next item in the sequence.
	 */
  int nextInt(int itemcount)
  {
    return (int)nextLong(itemcount);
  }

  /**
	 * Return the next value, skewed by the Zipfian distribution. The 0th item will be the most popular, followed by the 1st, followed
	 * by the 2nd, etc. (Or, if min != 0, the min-th item is the most popular, the min+1th item the next most popular, etc.) If you want the
	 * popular items scattered throughout the item space, use ScrambledZipfianGenerator instead.
	 */
  int nextInt()
  {
    return (int)nextLong(items);
  }

  /**
	 * Return the next value, skewed by the Zipfian distribution. The 0th item will be the most popular, followed by the 1st, followed
	 * by the 2nd, etc. (Or, if min != 0, the min-th item is the most popular, the min+1th item the next most popular, etc.) If you want the
	 * popular items scattered throughout the item space, use ScrambledZipfianGenerator instead.
	 */
  long nextLong()
  {
    return nextLong(items);
  }

  /**
	 * @todo Implement ZipfianGenerator.mean()
	 */
  double mean()
  {
    return 0;
    //throw new UnsupportedOperationException("@todo implement ZipfianGenerator.mean()");
  }
};

/*
    3.2 SkewedLatestGenerator
        input: a counterGenerator as a counter
        output： (1)nextInt() : return a int 
                    
*/

class SkewedLatestGenerator : public IntegerGenerator
{
  CounterGenerator _basis;
  ZipfianGenerator *_zipfian;

public:
  SkewedLatestGenerator(CounterGenerator basis) : _basis(basis)
  {
    /**
	 * Create a zipfian generator for the specified number of items.
	 * @param _items The number of items in the distribution.
	 */
    _zipfian = new ZipfianGenerator(_basis.lastInt());

    nextInt();
  }

  /**
	 * Generate the next string in the distribution,
	 * skewed Zipfian favoring the items most recently returned by the basis generator.
	 */
  int nextInt()
  {
    int max = _basis.lastInt();
    int nextint = max - _zipfian->nextInt(max);
    setLastInt(nextint);
    return nextint;
  }

  double mean()
  {
    return 0;
    //throw new UnsupportedOperationException("Can't compute mean of non-stationary distribution!");
  }
};

/*
    3.3 ScrambledZipfianGenerator
        input:  can  be modified
                default: @param _items The number of items in the distribution.
        output： (1) nextLong() or nextInt()
                 (2) mean(): I will try it 
                    
*/
class ScrambledZipfianGenerator : public IntegerGenerator
{

  ZipfianGenerator *gen;
  long _min, _max, _itemcount;

public:
  static constexpr double ZETAN = 26.46902820178302;
  static constexpr double USED_ZIPFIAN_CONSTANT = 0.99;
  static const long ITEM_COUNT = 10000000000L;

  /******************************* Constructors **************************************/

  /**
	 * Create a zipfian generator for the specified number of items.    
	 * @param _items The number of items in the distribution.
	 */
  ScrambledZipfianGenerator(long _items)
  {
    new (this) ScrambledZipfianGenerator(0, _items - 1);
  }

  /**
	 * Create a zipfian generator for items between min and max.
	 * @param _min The smallest integer to generate in the sequence.
	 * @param _max The largest integer to generate in the sequence.
	 */
  ScrambledZipfianGenerator(long _min, long _max)
  {
    new (this) ScrambledZipfianGenerator(_min, _max, ZipfianGenerator::ZIPFIAN_CONSTANT);
  }

  /**
	 * Create a zipfian generator for the specified number of items using the specified zipfian constant.
	 *
	 * @param _items The number of items in the distribution.
	 * @param _zipfianconstant The zipfian constant to use.
	 */
  /*
// not supported, as the value of zeta depends on the zipfian constant, and we have only precomputed zeta for one zipfian constant
	public ScrambledZipfianGenerator(long _items, double _zipfianconstant)
	{
		this(0,_items-1,_zipfianconstant);
	}
*/

  /**
	 * Create a zipfian generator for items between min and max (inclusive) for the specified zipfian constant. If you
	 * use a zipfian constant other than 0.99, this will take a long time to complete because we need to recompute zeta.
	 * @param min The smallest integer to generate in the sequence.
	 * @param max The largest integer to generate in the sequence.
	 * @param _zipfianconstant The zipfian constant to use.
	 */
  //���ҵ�
  ScrambledZipfianGenerator(long min, long max, double _zipfianconstant)
  {
    _min = min;
    _max = max;
    _itemcount = _max - _min + 1;
    if (_zipfianconstant == USED_ZIPFIAN_CONSTANT)
    {
      gen = new ZipfianGenerator(0, ITEM_COUNT, _zipfianconstant, ZETAN);
    }
    else
    {
      gen = new ZipfianGenerator(0, ITEM_COUNT, _zipfianconstant);
    }
  }

  /**************************************************************************************************/
  /**
       	 * Return the next long in the sequence.
       	 */
  long nextLong()
  {
    long ret = gen->nextLong();
    ret = _min + Utils::FNVhash64(ret) % _itemcount;
    setLastInt((int)ret);
    return ret;
  }
  /**
	 * Return the next int in the sequence.
	 */
  int nextInt()
  {
    return (int)nextLong();
  }

  /**
	 * since the values are scrambled (hopefully uniformly), the mean is simply the middle of the range.
	 */
  double mean()
  {
    return ((double)(((long)_min) + (long)_max)) / 2.0;
  }
};

/*
    3.4 UniformIntegerGenerator
        input:  lb and ub : the range of the generating key
        output： (1) nextInt()
                 (2) mean(): middle point of the range 
                    
*/

class UniformIntegerGenerator : public IntegerGenerator
{
  int _lb, _ub, _interval;

public:
  /**
	 * Creates a generator that will return integers uniformly randomly from the interval [lb,ub] inclusive (that is, lb and ub are possible values)
	 *
	 * @param lb the lower bound (inclusive) of generated values
	 * @param ub the upper bound (inclusive) of generated values
	 */
  UniformIntegerGenerator(int lb, int ub)
  {
    _lb = lb;
    _ub = ub;
    _interval = _ub - _lb + 1;
    srand((unsigned)time(NULL));
  }

  int nextInt()
  {
    double r = (double)(rand() / (double)RAND_MAX);
    int ret = r * _interval + _lb;
    IntegerGenerator::setLastInt(ret);
    return ret;
  }

  double mean()
  {
    return ((double)((long)(_lb + (long)_ub))) / 2.0;
  }
};

/*
    3.5 UniformGenerator  : return strings 
        input:  values
        output： (1) nextString and laststring 
                    
*/

class UniformGenerator : public Generator
{

  std::vector<std::string> _values;
  std::string _laststring;
  UniformIntegerGenerator *_gen;

public:
  /**
	 * Creates a generator that will return strings from the specified set uniformly randomly
	 */
  UniformGenerator(std::vector<std::string> values)
  {
    for (int i = 0; i < values.size(); i++)
    {
      _values.push_back(values.at(i));
    }
    //_values=(std::vector<std::string>)values.clone();
    _laststring.clear();
    _gen = new UniformIntegerGenerator(0, values.size() - 1);
  }

  /**
	 * Generate the next string in the distribution.
	 */
  std::string nextString()
  {
    _laststring = _values.at(_gen->nextInt());
    return _laststring;
  }

  /**
	 * Return the previous string generated by the distribution; e.g., returned from the last nextString() call.
	 * Calling lastString() should not advance the distribution or have any side effects. If nextString() has not yet
	 * been called, lastString() should return something reasonable.
	 */
  std::string lastString()
  {
    if (_laststring.empty())
    {
      nextString();
    }
    return _laststring;
  }
};

} // namespace generator

//+++++++++++++++++++++End of YCSB Generator+++++++++++++++++++++++++++++++++++++++++++++++++

void strRand(int length, char* value) {			
    char tmp;							
    std::string buffer;						

  
    std::random_device rd;					
    std::default_random_engine random(rd());	

    for (int i = 0; i < length; i++) {
        tmp = random() % 36;	
        if (tmp < 10) {			
            tmp += '0';
        } else {				
            tmp -= 10;
            tmp += 'A';
        }
        buffer += tmp;
    }
    memcpy(value,buffer.data(),length);
    return ;
}



//workload: 0: random; 1: scr; 2: sig
void TestACycle_RWOnly(BPlusTree* bpt,int load_items, int test_items, int scale,int read_ratio,int workload_flag,int bp_id){
  char k[32];
  char v[96];
  const int warmup_item = 100000;
  std::string mtr_path="/home/hkc/Plog/Plog-V4.4_multi/Plog-4.4_multi/testlog/item_"+std::to_string(bp_id);
  mtr_path+=".log";
  FILE* fpx=fopen(mtr_path.c_str(),"a");
  fprintf(fpx, "-------------BpTree-%d------TEST---------------------------------\n",bp_id);
  //FILE* fpx=fopen("/home/hkc/Plog/runtime-test.log","a");
  fprintf(fpx, "-------------Read Ratio: %d /100 --------------------------------\n",read_ratio);

   /* variable write ratio*/
  
  if(workload_flag == 0){
    fprintf(fpx, "-------------RANDOM Read Write Phase: %d KVs---------------------------------------\n",test_items);
      //std::cout<<"-------------RANDOM Read Write Phase: " <<test_items<< " KVs---------------------------------------\n";
  }else if(workload_flag == 1){
    fprintf(fpx, "-------------Scr Read Write Phase: %d KVs---------------------------------------\n",test_items);
      //std::cout<<"-------------Scr Read Write Phase: " <<test_items<< " KVs---------------------------------------\n";
  }else{
    fprintf(fpx, "-------------Sig Read Write Phase: %d KVs---------------------------------------\n",test_items);
      //std::cout<<"-------------Sig Read Write Phase: " <<test_items<< " KVs---------------------------------------\n";
  }
  
  //bypass_plog=1;
  //for(int x=1;x<=10;x++){
  bpt->SetIOStaic();
  generator::SkewedLatestGenerator sig(scale);
  generator::ScrambledZipfianGenerator szp(1, scale);
  
  //for(int x=1;x<10;x++){
  uint64_t read_all=0;
  uint64_t write_all=0;
  //for(int x=0;x<0;x++){
  int w_cnt=0;
  int r_cnt=0;
  auto t1 = std::chrono::steady_clock::now();
  for (int i = 0; i <= test_items; ++i) {
      off_t r = 0;
      if(workload_flag == 0){
        r = rand() % scale;
      }else if(workload_flag == 1){
        r = szp.nextInt();
      }else{
        r = sig.nextInt();
      }
      //r=i;
      snprintf(k, 32, "k%d", r);
      //int write_ratio=50;
      std::string value;
      if (rand()%100 >= read_ratio){
        strRand(96,v);
        //snprintf(v, 96, "v%d", r);
        auto tmp1 = std::chrono::steady_clock::now();
        off_t lsn = bpt->GetLSN();
        bpt->Put(k, v,lsn);
        bpt->IncreLSN();
        w_cnt+=1;
        auto tmp2 = std::chrono::steady_clock::now();
       
        write_all+=std::chrono::duration_cast<std::chrono::microseconds>(tmp2 - tmp1).count();
      }else{
        std::string value;
        auto tmp3 = std::chrono::steady_clock::now();
        bpt->Get(k,value);
        r_cnt+=1;
        auto tmp4 = std::chrono::steady_clock::now();
        
        read_all +=std::chrono::duration_cast<std::chrono::microseconds>(tmp4 - tmp3).count();
      }
      if(i%1000000==0 && i!=0 ){
        int hits_bp =0; int hits_glog =0; int hits_plog = 0; int disk_read=0; int io_consume=0; int error_cnt=0; int dirtys =0; int cleans =0;
        bpt->GetStatic(hits_bp, hits_glog, hits_plog, disk_read, io_consume, error_cnt, dirtys, cleans);
        fprintf(fpx, "chpt now:  %ld , log_off now: %ld\n", bpt->GetChpt(), bpt->GetLSN());
        fprintf(fpx, "error_cnt: %d ; Plog IO_consume time: %d us; read_all[cnt : ts (us)]:[ %d , %d ]; write_all[cnt : ts (us)]: [ %d , %d ]; hits[glog,plog,bp,disk]: [ %d , %d , %d , %d ]; LRU: [dirtys, cleans]: [ %d , %d ] \n",
                error_cnt, io_consume, r_cnt, read_all,w_cnt,write_all,hits_glog, hits_plog, hits_bp,disk_read, dirtys, cleans );
        //std::cout <<"error_cnt: "<<error_cnt<<", Plog IO_consume time: "<< io_consume 
        //          <<" us; read_all[cnt : ts (us)]: "<<r_cnt<<" , "<<read_all<<" ; write_all[cnt : ts (us)]: "
        //          <<w_cnt<<" , "<<write_all << " "
        //          <<global_lsn
        //          <<" hits[glog,plog,bp,disk]: [ "
        //          <<hits_glog<<" , "
        //          <<hits_plog<<" , "
        //          <<hits_bp<<" , "
        //          <<disk_read<<" ]. "
        //          <<" \n";
       bpt->ResetStatic();
      }
    }
    auto t2 = std::chrono::steady_clock::now();
    int plog_insert = 0; int leaf_insert=0; int leaf_split=0; int phy_plog_write=0; int phy_plog_read=0; 
    int phy_page_read =0; int phy_page_write=0; int logi_page_read=0; int logi_page_write=0;
    bpt->LoadIOStatic(plog_insert,leaf_insert, leaf_split, phy_plog_write, phy_plog_read,
                      phy_page_read, phy_page_write, logi_page_read, logi_page_write);
    fprintf(fpx, "Read Write total cnts: %d ; [w:r]: [ %d , %d ]; total time span= %ld ms; write_all_ts (us): %d , read_all_ts (us): %d ; plog_insert: %d , leaf_insert: %d , leaf_split: %d \n",
          test_items, w_cnt,r_cnt,std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000,
          write_all,read_all,plog_insert,leaf_insert,leaf_split);
    //std::cout << "Read Write total cnts " << test_items << "[w:r]: ["<<w_cnt<<" , "<< r_cnt<<" ]; total time span= "
    //          << std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000
    //          << " ms. write_all_ts (us): "<< write_all<<" , read_all_ts (us): "<<read_all<<" . plog_insert: "<<plog_insert<<" leaf_insert: "<<leaf_insert<<" leaf_split: "<<leaf_split
    //          << " total fore wait: "
              //<<fore_wait_all
    //          << " ms \n";
    fprintf(fpx, "chpt now: %ld , log_off now: %ld\n", bpt->GetChpt(), bpt->GetLSN());
    //std::cout << "chpt now: "<<bpt->GetChpt()<<" , log_off now: "<<global_lsn<<"\n";
  

    write_all =0;
    read_all=0;
    fprintf(fpx, "FINAL RANDOM Read Write page ios: phy_page_write: %d ; phy_page_read: %d ; logi_page_write: %d ; logi_page_read: %d ; phy_plog_write: %d , phy_plog_read: %d \n",
              phy_page_write,phy_page_read,logi_page_write,logi_page_read,phy_plog_write,phy_plog_read
    );
    //std::cout<<"FINAL RANDOM Read Write page ios: phy_page_write: "<<phy_page_write
    //         <<" phy_page_read:"<<phy_page_read
    //         <<" logi_page_write:"<<logi_page_write
    //         <<" logi_page_read: "<<logi_page_read
    //         <<" phy_plog_write:"<<phy_plog_write
    //         <<" phy_plog_read:"<<phy_plog_read<<"\n";
    //}

   /* end of variable write ratio*/

  fprintf(fpx,"-------------------------- TEST END --------------------------\n");
  //std::cout<<"-------------------------- TEST END --------------------------\n\n\n";

  fclose(fpx);
}


void Load(BPlusTree* bpt, int load_items, int test_items, int bp_id){
  char k[32];
  char v[96];
  //
  std::string mtr_path="/home/hkc/Plog/Plog-V4.4_multi/Plog-4.4_multi/testlog/item_"+std::to_string(bp_id);
  mtr_path+=".log";
  FILE* fpx=fopen(mtr_path.c_str(),"a");
  fprintf(fpx, "-------------BpTree-%d------LOAD---------------------------------\n",bp_id);
  fprintf(fpx, "-------------LOAD Phase: %d KVs---------------------------------------\n",load_items);
  //std::cout<<"-------------LOAD Phase: " <<load_items<< " KVs---------------------------------------\n";
  auto t1 = std::chrono::steady_clock::now();
  // sequential Insert
  for (int i = 0; i < load_items; ++i) {
    //int r = rand() % n;
    //int r = rand() % n;
    off_t r = i;
    snprintf(k, 32, "k%d", r);
    //snprintf(v, 96, "v%d", strRand(96));
    //snprintf(v, 96, "v%d", r);
    strRand(96,v);
    off_t lsn = bpt->GetLSN();
    bpt->Put(k, v,lsn);
    bpt->IncreLSN();
    if(i%1000000==0 && i!=0 ){
        fprintf(fpx, "chpt now: %ld , log_off now: %ld\n", 
              bpt->GetChpt(), bpt->GetLSN());
        //std::cout << "chpt now: "<<bpt->GetChpt()<<" , log_off now: "<<global_lsn<<"\n";
    }
    if(i%1000000==0&& i!=0 && i==-1){
      auto t2 = std::chrono::steady_clock::now();

      //std::cout << "chpt now: "<<bpt->GetChpt()<<" , log_off now: "<<bpt->GetLSN()<<"\n";

      int plog_insert = 0; int leaf_insert=0; int leaf_split=0; int phy_plog_write=0; int phy_plog_read=0; 
      int phy_page_read =0; int phy_page_write=0; int logi_page_read=0; int logi_page_write=0;
      bpt->LoadIOStatic(plog_insert,leaf_insert, leaf_split, phy_plog_write, phy_plog_read,
                      phy_page_read, phy_page_write, logi_page_read, logi_page_write);
      fprintf(fpx,"Sequential Load: %d KVs. time span=%d ms. plog_insert: %d , leaf_insert: %d , leaf_split: %d  \n", i, 
                  std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000, plog_insert, leaf_insert, leaf_split);
      fprintf(fpx, "chpt now: %ld , log_off now: %ld , FLU_contention is: %ld  FLU_contention_reloate is: %ld \n", 
                  bpt->GetChpt(), bpt->GetLSN());
      
      //std::cout << "Sequential Load " << i << " items: time span="
      //  << std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000
      //  << "ms. plog_insert: "<<plog_insert<<" leaf_insert: "<<leaf_insert<<" leaf_split: "<<leaf_split
      //  << "\n";
      //std::cout<<"page ios: phy_page_write: "<<phy_page_write
      //  <<" phy_page_read:"<<phy_page_read
      //  <<" logi_page_write:"<<logi_page_write
      //  <<" logi_page_read: "<<logi_page_read
      //  <<" phy_plog_write:"<<phy_plog_write
      //  <<" phy_plog_read:"<<phy_plog_read<<"\n";
      fprintf(fpx, "page ios: phy_page_write: %d , phy_page_read: %d , logi_page_write: %d , logi_page_read: %d , phy_plog_write: %d , phy_plog_read: %d \n",phy_page_write, phy_page_read,logi_page_write,logi_page_read,phy_plog_write,phy_plog_read);
      //fprintf(fpx,"fg lock contention: file %ld ms, state %ld ms\n",lock_contention_file/1000,lock_contention_state/1000);
      //fprintf(fpx,"curCacheSize:%d, elements:%d, FLU Size:%d \n",curCacheSize,cached_eles,curFLUSize);
      //fprintf(fpx,"bg ==>  lru batch flushes: %d; lru sparse flushes: %d; flu batch flushes: %d; flu sparse flushes: %d; \n",
      //          lru_batch_flushes,lru_sparse_flushes,flu_batch_flushes,flu_sparse_flushes);
      t1=t2;
    }
  
  }
  auto t2 = std::chrono::steady_clock::now();
  int plog_insert = 0; int leaf_insert=0; int leaf_split=0; int phy_plog_write=0; int phy_plog_read=0; 
  int phy_page_read =0; int phy_page_write=0; int logi_page_read=0; int logi_page_write=0;
  bpt->LoadIOStatic(plog_insert,leaf_insert, leaf_split, phy_plog_write, phy_plog_read,
                      phy_page_read, phy_page_write, logi_page_read, logi_page_write);
  fprintf(fpx," FINAL Sequential Load: %d KVs. time span= %d ms. plog_insert: %d , leaf_insert: %d , leaf_split: %d  \n", load_items, 
              std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000, plog_insert, leaf_insert, leaf_split);
  //std::cout << " Final Sequential Load " << load_items << " last items: time span="
  //            << std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000
  //            << " ms. plog_insert: "<<plog_insert<<" leaf_insert: "<<leaf_insert<<" leaf_split: "<<leaf_split
  //            << " \n";
  fprintf(fpx, "chpt now: %ld , log_off now: %ld\n", bpt->GetChpt(), bpt->GetLSN());
  //std::cout << "chpt now: "<<bpt->GetChpt()<<" , log_off now: "<<global_lsn<<"\n";
  //std::cout<<" page ios: phy_page_write: "<<phy_page_write
  //           <<" phy_page_read: "<<phy_page_read
  //           <<" logi_page_write: "<<logi_page_write
  //           <<" logi_page_read: "<<logi_page_read
  //           <<" phy_plog_write: "<<phy_plog_write
  //           <<" phy_plog_read: "<<phy_plog_read<<"\n";
  
  fprintf(fpx, "page ios: phy_page_write: %d , phy_page_read: %d , logi_page_write: %d , logi_page_read: %d , phy_plog_write: %d , phy_plog_read: %d \n",phy_page_write, phy_page_read,logi_page_write,logi_page_read,phy_plog_write,phy_plog_read);
  //fprintf(fpx, "fg lock contention: file %ld ms, state %ld ms\n",lock_contention_file/1000,lock_contention_state/1000);
  //fprintf(fpx, "curCacheSize:%d, elements:%d, FLU Size:%d \n",curCacheSize,cached_eles,curFLUSize);
  //fprintf(fpx, "bg ==>  lru batch flushes: %d; lru sparse flushes: %d; flu batch flushes: %d; flu sparse flushes: %d; \n",
  //        lru_batch_flushes,lru_sparse_flushes,flu_batch_flushes,flu_sparse_flushes);
  fclose(fpx);
  
  
}





void TestBaseline(BPlusTree* bpt, int load_items, int test_items, int scale_items,int bp_id){
  //1.load
  bpt->SetBaseline();
  bpt->SetLoadFlag(1);
  //load_flag =1;
  Load(bpt,load_items,test_items,bp_id);
  bpt->SetLoadFlag(0);
  afterLoad[bp_id]=1;
  //load_flag =0;
  //2. set base line config
  
  //3. test
  int cycle=0;
  int pagesenable[6]={2000,2000,4000,10000,20000,40000}; //0.5%, 1%, 2%，5%, 10%，20%
  for(int i =1; i<6;i++){
    kMaxPages = pagesenable[i];
    for(int j= 0; j<=2;j++){
      if(i==0){
        TestACycle_RWOnly(bpt,load_items,test_items,load_items,50,j,bp_id);  
      }else{
        TestACycle_RWOnly(bpt,load_items,test_items,scale_items,50,j,bp_id);
      }
      
    }
  }
  
  //for (int i=2;i>=0;i--){
  //  for(int x=0; x<=10;x+=2){
  //    TestACycle_RWOnly(bpt,load_items,test_items,scale_items,x*10,i,bp_id);
  //    testphase[bp_id][cycle++]=1;
  //  }
  //}
  
  aftertest[bp_id]=1;
  return;
}
void TestPlog(BPlusTree* bpt, int load_items, int test_items, int scale_items,int bp_id){
  //1.load
  //load_flag =1; 
  bpt->SetLoadFlag(1);
  //FLU_disabled=1;
  bpt->DisableFLUOrNot(1);
  Load(bpt,load_items,test_items, bp_id);
  //load_flag =0;
  bpt->SetLoadFlag(0);
  afterLoad[bp_id]=1;
  //2. set base line config
  bpt->SetPlog();
  //setPlog();
  //3. test
  int cycle =0;
  int pagesenable[6]={2000, 2000,4000,10000,20000,40000}; //0.5%, 1%, 2%，5%, 10%，20%
  for(int i =1; i<6;i++){
    kMaxPages = pagesenable[i];
    for(int j= 0; j<=2;j++){
      if(i==0){
        TestACycle_RWOnly(bpt,load_items,test_items,load_items,50,j,bp_id);  
      }else{
        TestACycle_RWOnly(bpt,load_items,test_items,scale_items,50,j,bp_id);
      }
      
    }
  }
  
  //for (int i=2;i>=0;i--){
  //  for(int x=0; x<=10;x+=2){
  //    TestACycle_RWOnly(bpt,load_items,test_items,scale_items,x*10,i, bp_id);
  //    testphase[bp_id][cycle++]=1;
  //  }
  //}
  
  aftertest[bp_id]=1;
  return;
}




int main(int argc, char const* argv[]) {
  (void)argc;
  (void)argv;
  //int client_id = atoi(argv[1]);
  int test_plog=1;
  int clients=16;
  
  int load_items  = 30000000;
  int test_items  = 10000000;
  int scale_items = 20000000;
  
  //int load_items  = 15000000;
  //int test_items  = 5000000;
  //int scale_items = 5000000;
  
  
  /*
  int load_items  = 3000000;
  int test_items  =  3000000;
  int scale_items = 3000000;
  */
  if(test_plog == 1){
    srand(time(0));
    bool enable_plog =true;
    //int client_id=16;
    std::deque<BPlusTree*> Trees;
    std::thread BackGround[clients];
    std::string Dir="/media/hkc/csd_3/DirTrees/test";
    for(int i=0;i<clients;i++){
      std::string DB_path = Dir+std::to_string(i);
      DB_path+="/";
      std::string db = DB_path+"test.db";
      std::string log = DB_path+"test.log";
      std::string chpt = DB_path+"chpt.log";
      BackGround[i]=std::thread(TestPlog,new BPlusTree(db.c_str(), log.c_str(),chpt.c_str(),i,enable_plog),load_items,test_items,scale_items,i);
      BackGround[i].detach(); 
    }
  }else{
    srand(time(0));
    bool enable_plog =false;
    std::deque<BPlusTree*> Trees;
    std::thread BackGround[clients];
    std::string Dir="/media/hkc/csd_3/DirTrees/test";
    for(int i=0;i<clients;i++){
      std::string DB_path = Dir+std::to_string(i);
      DB_path+="/";
      std::string db = DB_path+"test.db";
      std::string log = DB_path+"test.log";
      std::string chpt = DB_path+"chpt.log";
      BackGround[i]=std::thread(TestBaseline,new BPlusTree(db.c_str(), log.c_str(),chpt.c_str(),i,enable_plog),load_items,test_items,scale_items,i);
      BackGround[i].detach(); 
    }
  }
  
  

  /*Background aio*/

  //std::thread BackGround;

  //BackGround=std::thread(BackGroundManager);
  //BackGround.join();
  //BackGround.detach(); 



  
  //TestBaseline(bpt,load_items,test_items,scale_items);
  //TestPlog(bpt,load_items,test_items,scale_items);
  auto t1 = std::chrono::steady_clock::now();
  std::mutex mu;
  int test_cnt=0;
  while(true){
    int total_malloc =0;
    for(int i=0;i<32;i++){
      if(afterLoad[i]==1){
        auto t2 = std::chrono::steady_clock::now();
        auto tmp = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000;
        std::cout<<"Btree-"<<i<<" Load Done, time used: "<<tmp<<" \n";
        mu.lock();
        afterLoad[i]=2;
        mu.unlock();
      }
      if(aftertest[i]==1){
        auto t2 = std::chrono::steady_clock::now();
        auto tmp = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000;
        std::cout<<"Btree-"<<i<<" TEST Done, time used: "<<tmp<<" \n";
        mu.lock();
        aftertest[i]=2;
        test_cnt++;
        mu.unlock();
      for (int j=0;j<50;j++){
        if(testphase[i][j] == 1){
          auto t2 = std::chrono::steady_clock::now();
          auto tmp = std::chrono::duration_cast<std::chrono::microseconds>(t2 - t1).count()/1000;
          std::cout<<"Btree-"<<i<<" cycle-"<<j<<" Done, time used: "<<tmp<<" \n";
          mu.lock();
          testphase[i][j]=2;
          mu.unlock();
        }
      }
      } 
      sleep(10);
      //if(test_cnt >= test_cnt) break;
    }
  }
  return 0;
}